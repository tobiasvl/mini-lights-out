<!-- Standalone Generated By Octo (octo-ide.com) -->
<script>data={"program":":alias steps vd\n\n: main\n\t# set up title screen\n\tclear\n\tv0 := 50\n\t# you probably want to remove the following line if you're running on something that beeps\n\tbuzzer := v0\n\ti := logo\n\tva := 17\n\tvb := 8\n\tvc := 7\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\t\n\tva := 17\n\tvb += 8\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 1\n\n: title-screen\n\tloop\n\t\tv0 := 50\n\t\tdelay := v0\t\n\t\t# if the last blink inverted the title screen back, we buzz (ie. flash in Octo)\n\t\t# you probably want to remove this if you're running on something that beeps\n\t\tif vf == 1 then buzzer := v0\n\t\ti := keys\n\t\tload ve\n\n\t\tloop\n\t\t\tif v0 key then jump init-game\n\t\t\tif v1 key then jump init-game\n\t\t\tif v2 key then jump init-game\n\t\t\tif v3 key then jump init-game\n\t\t\tif v4 key then jump init-game\n\t\t\tif v5 key then jump init-game\n\t\t\tif v6 key then jump init-game\n\t\t\tif v7 key then jump init-game\n\t\t\tif v8 key then jump init-game\n\t\t\tif v9 key then jump init-game\n\t\t\tif va key then jump init-game\n\t\t\tif vb key then jump init-game\n\t\t\tif vc key then jump init-game\n\t\t\tif vd key then jump init-game\n\t\t\tif ve key then jump init-game\n\t\t\tvf := 0x0f # we use vf below\n\t\t\tif vf key then jump init-game\n\t\t\tvf := delay\n\t\t\tif vf != 0 then\n\t\tagain\n\n\t\t# invert title screen\n\t\ti := light\n\t\tva := -8\n\t\tvb := -15\n\t\tloop\n\t\t\tvb += 15\n\t\t\twhile vb != 45\n\t\t\tloop\n\t\t\tva += 8\n\t\t\t\twhile va != 64\n\t\t\t\tif vb == 30 then sprite va vb 2\n\t\t\t\tif vb != 30 then sprite va vb 15\n\t\t\tagain\n\t\t\tva := -8\n\t\tagain\n\tagain\n\n: init-game\n\t# initialize a game\n\tsteps := 0\n\tbuzzer := steps\n\ti := light-on\n\t\n\t# randomize grid\n\tvc := random 255\n\tve := random 255\n\t# if all lights are off already, we need a new configuration\n\tvb := vc\n\tvb &= ve\n\tif vb == 0 then jump init-game\n\n\t# draw grid\n\tclear\n\tva := 8\n\tvb := -8\n\tloop\n\t\tif vb == 0 then vc := ve\n\t\tif vb == 16 then vc := ve\n\t\tvb += 8\n\t\twhile vb != 32\n\t\tloop\n\t\t\tva += 8\n\t\t\twhile va != 48\n\t\t\tsprite va vb 7\n\t\t\tvc >>= vc\n\t\t\tif vf == 1 begin\n\t\t\t\ti := light\n\t\t\t\tsprite va vb 8\n\t\t\t\ti := light-on\n\t\t\tend\n\t\tagain\n\t\tva := 8\n\tagain\n\t\n\tdraw-steps\n\n: game-loop\n\t# wait for input\n\tv3 := key\n\t# try toggling the light\n\tjump toggle\n\t: toggled\n\t# erase step counter\n\tdraw-steps\n\t# increment step counter\n\tsteps += 1\n\t# if we overflow the BCD step counter, the game is lost and we just\n\t# reset the game\n\tif steps == 100 then jump main\n\t# draw step counter\n\tdraw-steps\n\t\n: check-win\n\t# check if all lights are off.\n\t# draw a single pixel in the upper right corner of the border of every light\n\t# if it fails to collide anywhere, it's found a lit light and returns\n\ti := test\n\tva := 8\n\tvb := 8\n\tloop\n\t\tvb += 8\n\t\twhile vb != 48\n\t\tloop\n\t\t\tva += 8\n\t\t\twhile va != 48\n\t\t\tsprite va vb 1\n\t\t\tsprite va vb 1\n\t\t\t# if we erased, this light is on\n\t\t\tif vf == 1 then jump game-loop\n\t\tagain\n\t\tva := 8\n\tagain\n\n\t# the game is won!\n\tclear\n\tdraw-steps\n\t\n\ti := congrats-text\n\tva := 20\n\tvb := 8\n\tvc := 7\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\t\n\tva := 12\n\tvb += 8\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\ti += vc\n\tva += 8\n\tsprite va vb 7\n\tjump title-screen\n\n: draw-steps\n\ti := steps-bcd\n\tbcd steps\n\tload v2\n\tva := 52\n\tvb := 14\n\ti := hex v1\n\tsprite va vb 5\n\tva += 5\n\ti := hex v2\n\tsprite va vb 5\n\treturn\n\n: toggle\n\t# map pressed key to light\n\tv0 := v3\n\ti := keys\n\ti += v0\n\tload v0\n\t\n\tva := v0\n\tvb := v0\n\n\t# X position of pressed light\n\tvc := 0b00011\n\tva &= vc\n\tva <<= va\n\tva <<= va\n\tva <<= va\n\tva += 16\n\n\t# Y position of pressed light\n\tvc := 0b11100\n\tvb &= vc\n\tvb <<= vb\n\t\n\ti := test\n\tsprite va vb 1\n\tsprite va vb 1\n\t\n\tif vf == 0 begin\n\t\tv0 := 10\n\t\tbuzzer := v0\n\t\tjump game-loop\n\tend\n\t\n\ti := light\n\t\n\t# toggle pressed light\n\tsprite va vb 8\n\t\n\t# toggle light to the left\n\tv3 := va\n\tva += -8\n\tif va == 8 then va += -32\n\tsprite va vb 8\n\t\n\t# toggle light to the right\n\tva := v3\n\tva += 8\n\tif va == 48 then va += -32\n\tsprite va vb 8\n\tva := v3\n\t\n\t# toggle light above\n\tvb += -8\n\tsprite va vb 8\n\t\n\t# toggle light below\n\tvb += 16\n\tsprite va vb 8\n\t\n\tjump toggled\n\n: keys\n\t# maps a key to its grid position\n\t13 0 1 2 4 5 6 8 9 10 12 14 3 7 11 15\n\n: logo\n\t# LIGHTS\n\t#  OUT\n\t0b10000100\n\t0b10000100\n\t0b10000100\n\t0b10000100\n\t0b10000100\n\t0b10000100\n\t0b11110100\n\t\n\t0b01110001\n\t0b11001001\n\t0b10000001\n\t0b10011001\n\t0b10001001\n\t0b11001001\n\t0b01110001\n\t\n\t0b00010111\n\t0b00010001\n\t0b00010001\n\t0b11110001\n\t0b00010001\n\t0b00010001\n\t0b00010001\n\t\n\t0b11001110\n\t0b00010001\n\t0b00010000\n\t0b00001110 : test # a 1 pixel sprite we use for collision\n\t0b00000001\n\t0b00010001\n\t0b00001110\n\t\n\t0b01110001\n\t0b11011001\n\t0b10001001\n\t0b10001001\n\t0b10001001\n\t0b11011001\n\t0b01110000\n\t\n\t0b00010111\n\t0b00010001\n\t0b00010001\n\t0b00010001\n\t0b00010001\n\t0b00010001\n\t0b11100001\n\t\n\t0b11000000\n\t\n: congrats-text\n\t# YOU\n\t# WIN\n\t0b10000010\n\t0b01000101\n\t0b00101001\n\t0b00010001\n\t0b00010001\n\t0b00010001\n\t0b00010000\n\t\n\t0b11110001\n\t0b10011001\n\t0b00001001\n\t0b00001001\n\t0b00001001\n\t0b10011001\n\t0b11110000\n\n\t0b00001000\n\t0b00001000\n\t0b00001000\n\t0b00001000\n\t0b00001000\n\t0b00001000\n\t0b11110000\n\t\n\t0b01000100\n\t0b01000100\n\t0b00101010\n\t0b00101010\n\t0b00101010\n\t0b00010001\n\t0b00010001\n\t\n\t0b01010010\n\t0b01010011\n\t0b10010010\n\t0b10010010\n\t0b10010010\n\t0b00010010\n\t0b00010010\n\t\n\t0b00010000\n\t0b00010000\n\t0b10010000\n\t0b10010000\n\t0b01010000\n\t0b00110000\n\t0b00010000\n\n: light-on\n\t0b00000000\n\t0b01111110\n\t0b01111110\n\t0b01111110\n\t0b01111110\n\t0b01111110\n\t0b01111110\n\n: light\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\t0b11111111\n\n: steps-bcd","options":{"tickrate":7,"fillColor":"#FFCC00","fillColor2":"#FF6600","blendColor":"#662200","backgroundColor":"#996600","buzzColor":"#FFAA00","quietColor":"#000000","shiftQuirks":0,"loadStoreQuirks":0,"vfOrderQuirks":0,"clipQuirks":1,"vBlankQuirks":1,"jumpQuirks":0,"screenRotation":0,"maxSize":3215,"touchInputMode":"seg16"},"rom":[0,224,96,50,240,24,163,200,106,17,107,8,108,7,218,183,252,30,122,8,218,183,252,30,122,8,218,183,252,30,122,8,218,183,106,17,123,8,252,30,122,8,218,183,252,30,122,8,218,183,252,30,122,8,218,177,96,50,240,21,79,1,240,24,163,184,254,101,224,161,18,174,225,161,18,174,226,161,18,174,227,161,18,174,228,161,18,174,229,161,18,174,230,161,18,174,231,161,18,174,232,161,18,174,233,161,18,174,234,161,18,174,235,161,18,174,236,161,18,174,237,161,18,174,238,161,18,174,111,15,239,161,18,174,255,7,63,0,18,68,164,36,106,248,107,241,123,15,75,45,18,172,122,8,74,64,18,168,75,30,218,178,59,30,218,191,18,152,106,248,18,146,18,56,109,0,253,24,164,29,204,255,206,255,139,192,139,226,75,0,18,174,0,224,106,8,107,248,75,0,140,224,75,16,140,224,123,8,75,32,18,238,122,8,74,48,18,234,218,183,140,198,63,1,18,232,164,36,218,184,164,29,18,212,106,8,18,198,35,80,243,10,19,102,35,80,125,1,77,100,18,0,35,80,163,225,106,8,107,8,123,8,75,48,19,30,122,8,74,48,19,26,218,177,218,177,79,1,18,240,19,10,106,8,19,4,0,224,35,80,163,243,106,20,107,8,108,7,218,183,252,30,122,8,218,183,252,30,122,8,218,183,106,12,123,8,252,30,122,8,218,183,252,30,122,8,218,183,252,30,122,8,218,183,18,56,164,51,253,51,242,101,106,52,107,14,241,41,218,181,122,5,242,41,218,181,0,238,128,48,163,184,240,30,240,101,138,0,139,0,108,3,138,194,138,174,138,174,138,174,122,16,108,28,139,194,139,190,163,225,218,177,218,177,63,0,19,148,96,10,240,24,18,240,164,36,218,184,131,160,122,248,74,8,122,224,218,184,138,48,122,8,74,48,122,224,218,184,138,48,123,248,218,184,123,16,218,184,18,244,13,0,1,2,4,5,6,8,9,10,12,14,3,7,11,15,132,132,132,132,132,132,244,113,201,129,153,137,201,113,23,17,17,241,17,17,17,206,17,16,14,1,17,14,113,217,137,137,137,217,112,23,17,17,17,17,17,225,192,130,69,41,17,17,17,16,241,153,9,9,9,153,240,8,8,8,8,8,8,240,68,68,42,42,42,17,17,82,83,146,146,146,18,18,16,16,144,144,80,48,16,0,126,126,126,126,126,126,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255]}</script>
<script>"use strict";

function invertKeymap(k) {
	return Object.keys(k).reduce((a,b) => {
		Object.keys(k[b]).forEach(x => a[x]=+b)
		return a
	}, {})
}

function getPref(key) {
	try { return JSON.parse(localStorage.getItem(key)) }
	catch(e) { console.log(e); return null }
}
function setPref(key, value) {
	try { localStorage.setItem(key, JSON.stringify(value)) }
	catch(e) { console.log(e); }
}

var keymap = (this.STATIC_KEYMAP) || getPref('octoKeymap') || {
	0x0: { x:1 },
	0x1: { 1:1 },
	0x2: { 2:1 },
	0x3: { 3:1 },
	0x4: { q:1 },
	0x5: { w:1, ArrowUp:1 },
	0x6: { e:1, ' ':1 },
	0x7: { a:1, ArrowLeft:1 },
	0x8: { s:1, ArrowDown:1 },
	0x9: { d:1, ArrowRight:1 },
	0xA: { z:1 },
	0xB: { c:1 },
	0xC: { 4:1 },
	0xD: { r:1 },
	0xE: { f:1 },
	0xF: { v:1 },
}

var keymapInverse = invertKeymap(keymap)

var font = [
	0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
	0x20, 0x60, 0x20, 0x20, 0x70, // 1
	0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
	0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
	0x90, 0x90, 0xF0, 0x10, 0x10, // 4
	0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
	0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
	0xF0, 0x10, 0x20, 0x40, 0x40, // 7
	0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
	0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
	0xF0, 0x90, 0xF0, 0x90, 0x90, // A
	0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
	0xF0, 0x80, 0x80, 0x80, 0xF0, // C
	0xE0, 0x90, 0x90, 0x90, 0xE0, // D
	0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
	0xF0, 0x80, 0xF0, 0x80, 0x80  // F
];

var bigfont = [
	0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, // 0
	0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, // 1
	0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // 2
	0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 3
	0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, // 4
	0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 5
	0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 6
	0xFF, 0xFF, 0x03, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, // 7
	0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 8
	0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 9
	0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, // A
	0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, // B
	0x3C, 0xFF, 0xC3, 0xC0, 0xC0, 0xC0, 0xC0, 0xC3, 0xFF, 0x3C, // C
	0xFC, 0xFE, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFC, // D
	0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // E
	0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0  // F
];

////////////////////////////////////
//
//   The Chip8 Interpreter:
//
////////////////////////////////////

function Emulator() {

	// persistent configuration settings
	this.tickrate           = 20;
	this.fillColor          = "#FFCC00";
	this.fillColor2         = "#FF6600";
	this.blendColor         = "#662200";
	this.backgroundColor    = "#996600";
	this.buzzColor          = "#FFAA00";
	this.quietColor         = "#000000";
	this.shiftQuirks        = false;
	this.loadStoreQuirks    = false;
	this.vfOrderQuirks      = false;
	this.clipQuirks         = false;
	this.jumpQuirks         = false;
	this.vBlankQuirks       = false;
	this.enableXO           = true;
	this.screenRotation     = 0;
	this.maxSize            = 3584;
	this.touchInputMode     = 'none';
	this.maskFormatOverride = true;
	this.numericFormatStr   = "default";

	// interpreter state
	this.p  = [[],[]];  // pixels
	this.m  = [];       // memory (bytes)
	this.r  = [];       // return stack
	this.v  = [];       // registers
	this.pc = 0;        // program counter
	this.i  = 0;        // index register
	this.dt = 0;        // delay timer
	this.st = 0;        // sound timer
	this.hires = false; // are we in SuperChip high res mode?
	this.flags = [];    // semi-persistent hp48 flag vars
	this.pattern = [];  // audio pattern buffer
	this.plane = 1;     // graphics plane
	this.profile_data = {};

	// control/debug state
	this.keys = {};       // track keys which are pressed
	this.waiting = false; // are we waiting for a keypress?
	this.waitReg = -1;    // destination register of an awaited key
	this.halted = true;
	this.breakpoint = false;
	this.metadata = {};
	this.tickCounter = 0;

	// external interface stubs
	this.exitVector  = function() {}                                   // fired by 'exit'
	this.importFlags = function() { return [0, 0, 0, 0, 0, 0, 0, 0]; } // load persistent flags
	this.exportFlags = function(flags) {}                              // save persistent flags
	this.buzzTrigger = function(ticks, remainingTicks) {}                              // fired when buzzer played

	this.init = function(rom) {
		// initialise memory with a new array to ensure that it is of the right size and is initiliased to 0
		this.m = this.enableXO ? new Uint8Array(0x10000) : new Uint8Array(0x1000);

		this.p = [[], []];
		if (this.enableXO)
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		else
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }

		// initialize memory
		for(var z = 0; z < 32*64;          z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		for(var z = 0; z < font.length;    z++) { this.m[z] = font[z]; }
		for(var z = 0; z < bigfont.length; z++) { this.m[z + font.length] = bigfont[z]; }
		for(var z = 0; z < rom.rom.length; z++) { this.m[0x200+z] = rom.rom[z]; }
		for(var z = 0; z < 16;             z++) { this.v[z] = 0; }
		for(var z = 0; z < 16;             z++) { this.pattern[z] = 0; }

		// initialize interpreter state
		this.r = [];
		this.pc = 0x200;
		this.i  = 0;
		this.dt = 0;
		this.st = 0;
		this.hires = false;
		this.plane = 1;

		// initialize control/debug state
		this.keys = {};
		this.waiting = false;
		this.waitReg = -1;
		this.halted = false;
		this.breakpoint = false;
		this.stack_breakpoint = -1;
		this.metadata = rom;
		this.tickCounter = 0;
		this.profile_data = {};
	}

	this.writeCarry = function(dest, value, flag) {
		this.v[dest] = (value & 0xFF);
		this.v[0xF] = flag ? 1 : 0;
		if (this.vfOrderQuirks) {
			this.v[dest] = (value & 0xFF);
		}
	}

	this.math = function(x, y, op) {
		// basic arithmetic opcodes
		switch(op) {
			case 0x0: this.v[x]  = this.v[y]; break;
			case 0x1: this.v[x] |= this.v[y]; break;
			case 0x2: this.v[x] &= this.v[y]; break;
			case 0x3: this.v[x] ^= this.v[y]; break;
			case 0x4:
				var t = this.v[x]+this.v[y];
				this.writeCarry(x, t, (t > 0xFF));
				break;
			case 0x5:
				var t = this.v[x]-this.v[y];
				this.writeCarry(x, t, (this.v[x] >= this.v[y]));
				break;
			case 0x7:
				var t = this.v[y]-this.v[x];
				this.writeCarry(x, t, (this.v[y] >= this.v[x]));
				break;
			case 0x6:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] >> 1;
				this.writeCarry(x, t, (this.v[y] & 0x1));
				break;
			case 0xE:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] << 1;
				this.writeCarry(x, t, ((this.v[y] >> 7) & 0x1));
				break;
			default:
				haltBreakpoint("unknown math opcode "+op);
		}
	}

	this.misc = function(x, rest) {
		// miscellaneous opcodes
		switch(rest) {
			case 0x01:
				this.plane = (x & 0x3);
				break;
			case 0x02:
				for(var z = 0; z < 16; z++) {
					this.pattern[z] = this.m[this.i+z];
				}
				break;
			case 0x07: this.v[x] = this.dt; break;
			case 0x0A: this.waiting = true; this.waitReg = x; break;
			case 0x15: this.dt = this.v[x]; break;
			case 0x18: this.buzzTrigger(this.v[x], this.st); this.st = this.v[x]; break;
			case 0x1E: this.i = (this.i + this.v[x])&0xFFFF; break;
			case 0x29: this.i = ((this.v[x] & 0xF) * 5); break;
			case 0x30: this.i = ((this.v[x] & 0xF) * 10 + font.length); break;
			case 0x33:
				this.m[this.i]   = Math.floor(this.v[x]/100)%10;
				this.m[this.i+1] = Math.floor(this.v[x]/10)%10;
				this.m[this.i+2] = this.v[x]%10;
				break;
			case 0x55:
				for(var z = 0; z <= x; z++) { this.m[this.i+z] = this.v[z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x65:
				for(var z = 0; z <= x; z++) { this.v[z] = this.m[this.i+z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x75:
				for(var z = 0; z <= x; z++) { this.flags[z] = this.v[z]; }
				this.exportFlags(this.flags);
				break;
			case 0x85:
				this.flags = this.importFlags();
				if (typeof this.flags == "undefined" || this.flags == null) {
					this.flags = [0, 0, 0, 0, 0, 0, 0, 0];
				}
				for(var z = 0; z <= x; z++) { this.v[z] = this.flags[z]; }
				break;
			default:
				haltBreakpoint("unknown misc opcode "+rest);
		}
	}

	this.sprite = function sprite(x, y, len) {
		this.v[0xF] = 0x0;
		var rowSize = this.hires ? 128 : 64;
		var colSize = this.hires ?  64 : 32;
		var i = this.i;
		for(var layer = 0; layer < 2; layer++) {
			if ((this.plane & (layer+1)) == 0) { continue; }
			if (len == 0) {
				// draw a SuperChip 16x16 sprite
				for(var a = 0; a < 16; a++) {
					for(var b = 0; b < 16; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+(a*2)+(b > 7 ? 1:0)] >> (7-(b%8))) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += 32;
			}
			else {
				// draw a Chip8 8xN sprite
				for(var a = 0; a < len; a++) {
					for(var b = 0; b < 8; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+a] >> (7-b)) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += len;
			}
		}
	}

	this.call = function(nnn) {
		if (this.r.length >= 12) {
			haltBreakpoint("call stack overflow.");
		}
		this.r.push(this.pc);
		this.pc = nnn
	}

	this.jump0 = function(nnn) {
		if (this.jumpQuirks) { this.pc = nnn + this.v[(nnn >> 8)&0xF];  }
		else                 { this.pc = nnn + this.v[0]; }
	}

	this.machine = function(nnn) {
		if (nnn == 0x000) { this.halted = true; return; }
		haltBreakpoint("machine code is not supported.");
	}

	this.skip = function() {
		var op = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		this.pc += (op == 0xF000) ? 4 : 2;
	}

	this.opcode = function() {
		// Increment profilining data
		this.profile_data[this.pc] = (this.profile_data[this.pc] || 0) + 1;

		// decode the current opcode
		var op  = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		var o   = (this.m[this.pc  ] >> 4) & 0x00F;
		var x   = (this.m[this.pc  ]     ) & 0x00F;
		var y   = (this.m[this.pc+1] >> 4) & 0x00F;
		var n   = (this.m[this.pc+1]     ) & 0x00F;
		var nn  = (this.m[this.pc+1]     ) & 0x0FF;
		var nnn = op & 0xFFF;
		this.pc += 2;

		// execute a simple opcode
		if (op == 0x00E0) {
			// clear
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = 0;
				}
			}
			return;
		}
		if (op == 0x00EE) {
			// return
			this.pc = this.r.pop();
			return;
		}
		if ((op & 0xF0FF) == 0xE09E) {
			// if -key
			if (Object.keys(keymap[this.v[x]]).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xF0FF) == 0xE0A1) {
			// if key
			if (!Object.keys(keymap[this.v[x]]).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xFFF0) == 0x00C0) {
			// scroll down n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = this.p[layer].length - 1; z >= 0; z--) {
					this.p[layer][z] = (z >= rowSize * n) ? this.p[layer][z - (rowSize * n)] : 0;
				}
			}
			return;
		}
		if ((op & 0xFFF0) == 0x00D0) {
			// scroll up n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = (z < (this.p[layer].length - rowSize * n)) ? this.p[layer][z + (rowSize * n)] : 0;
				}
			}
			return;
		}
		if (op == 0x00FB) {
			// scroll right 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = rowSize-1; b >= 0; b--) {
						this.p[layer][a + b] = (b > 3) ? this.p[layer][a + b - 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FC) {
			// scroll left 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = 0; b < rowSize; b++) {
						this.p[layer][a + b] = (b < rowSize - 4) ? this.p[layer][a + b + 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FD) {
			// exit
			this.halted = true;
			this.exitVector();
			return;
		}
		if (op == 0x00FE) {
			// lores
			this.hires = false;
			this.p = [[], []];
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0x00FF) {
			// hires
			this.hires = true;
			this.p = [[], []];
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0xF000) {
			// long memory reference
			this.i = ((this.m[this.pc] << 8) | (this.m[this.pc+1])) & 0xFFFF;
			this.pc += 2;
			return;
		}

		if (o == 0x5 && n != 0) {
			if (n == 2) {
				// save range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x-z]; }}
				return;
			}
			else if (n == 3) {
				// load range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.v[x+z] = this.m[this.i+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.v[x-z] = this.m[this.i+z]; }}
				return;
			}
			else {
				haltBreakpoint("unknown opcode "+op);
			}
		}
		if (o == 0x9 && n != 0) {
			haltBreakpoint("unknown opcode "+op);
		}

		// dispatch complex opcodes
		switch(o) {
			case 0x0: this.machine(nnn);                            break;
			case 0x1: this.pc = nnn;                                break;
			case 0x2: this.call(nnn);                               break;
			case 0x3: if (this.v[x] == nn)        { this.skip(); }  break;
			case 0x4: if (this.v[x] != nn)        { this.skip(); }  break;
			case 0x5: if (this.v[x] == this.v[y]) { this.skip(); }  break;
			case 0x6: this.v[x] = nn;                               break;
			case 0x7: this.v[x] = (this.v[x] + nn) & 0xFF;          break;
			case 0x8: this.math(x, y, n);                           break;
			case 0x9: if (this.v[x] != this.v[y]) { this.skip(); }  break;
			case 0xA: this.i = nnn;                                 break;
			case 0xB: this.jump0(nnn);                              break;
			case 0xC: this.v[x] = (Math.random()*256)&nn;           break;
			case 0xD: this.sprite(this.v[x], this.v[y], n);         break;
			case 0xF: this.misc(x, nn);                             break;
			default: haltBreakpoint("unknown opcode "+o);
		}
	}

	this.tick = function() {
		if (this.halted) { return; }
		this.tickCounter++;
		try {
			this.opcode();
		}
		catch(err) {
			console.log("halted: " + err);
			this.halted = true;
		}
	}
}
</script>
<script>"use strict";

////////////////////////////////////
//
//   Emulator Execution
//
////////////////////////////////////

var scaleFactor = 5;
var renderTarget = "target";

const optionFlags = [
	"tickrate",
	"fillColor",
	"fillColor2",
	"blendColor",
	"backgroundColor",
	"buzzColor",
	"quietColor",
	"shiftQuirks",
	"loadStoreQuirks",
	"vfOrderQuirks",
	"clipQuirks",
	"vBlankQuirks",
	"jumpQuirks",
	"screenRotation",
	"maxSize",
	"touchInputMode",
]
function unpackOptions(emulator, options) {
	optionFlags.forEach(x => { if (x in options) emulator[x] = options[x] })
	if (options["enableXO"]) emulator.maxSize = 65024 // legacy option
}
function packOptions(emulator) {
	const r = {}
	optionFlags.forEach(x => r[x] = emulator[x])
	return r
}

function setRenderTarget(scale, canvas) {
	scaleFactor = scale;
	renderTarget = canvas;
	var c = document.getElementById(canvas);

	// Remove any existing previous delta frame so first frame is always drawn:
	c.last = undefined;

	var w  = scaleFactor * 128;
	var h  = scaleFactor *  64;
	var wm = (scaleFactor * -64) + "px";
	var hm = (scaleFactor * -32) + "px";

	if (emulator.screenRotation == 90 || emulator.screenRotation == 270) {
		c.width  = h;
		c.height = w;
	}
	else {
		c.width  = w;
		c.height = h;
	}
}

function getTransform(emulator, g) {
	g.setTransform(1, 0, 0, 1, 0, 0);
	var x = scaleFactor * 128;
	var y = scaleFactor *  64;
	switch(emulator.screenRotation) {
		case 90:
			g.rotate(0.5 * Math.PI);
			g.translate(0, -y);
			break;
		case 180:
			g.rotate(1.0 * Math.PI);
			g.translate(-x, -y);
			break;
		case 270:
			g.rotate(1.5 * Math.PI);
			g.translate(-x, 0);
			break;
		default:
			/* nothing to do */
	}
}


function arrayEqual(a, b) {
	var length = a.length;
	if (length !== b.length) { return false; }
	for (var i = 0; i < length; i++) {
		if (a[i] !== b[i]) { return false; }
	}
	return true;
}

function getColor(id) {
	switch(id) {
		case 0: return emulator.backgroundColor;
		case 1: return emulator.fillColor;
		case 2: return emulator.fillColor2;
		case 3: return emulator.blendColor;
	}
	throw "invalid color: " + id;
}

function renderDisplay(emulator) {
	var c = document.getElementById(renderTarget);

	// Canvas rendering can be expensive. Exit out early if nothing has changed.
	var colors = [emulator.backgroundColor, emulator.fillColor, emulator.fillColor2, emulator.blendColor];
	if (c.last !== undefined) {
		if (arrayEqual(c.last.p[0], emulator.p[0]) && arrayEqual(c.last.p[1], emulator.p[1])
				&& arrayEqual(c.last.colors, colors)) {
			return;
		}
		if (c.last.hires !== emulator.hires)
			c.last = undefined;  // full redraw when switching resolution
	}
	var g = c.getContext("2d");
	getTransform(emulator, g);
	var w      = emulator.hires ? 128         : 64;
	var h      = emulator.hires ? 64          : 32;
	var size   = emulator.hires ? scaleFactor : scaleFactor*2;
	var lastPixels = c.last !== undefined? c.last.p: [[], []]

	g.scale(size, size)
	var z = 0;
	for(var y = 0; y < h; ++y) {
		for(var x = 0; x < w; ++x, ++z) {
			var oldColorIdx = lastPixels[0][z] + (lastPixels[1][z] << 1);
			var colorIdx = emulator.p[0][z] + (emulator.p[1][z] << 1);
			if (oldColorIdx !== colorIdx) {
				g.fillStyle = getColor(colorIdx);
				g.fillRect(x, y, 1, 1);
			}
		}
	}
	g.scale(1, 1) //restore scale to 1,1 just in case

	c.last = {
		colors: colors,
		p: [emulator.p[0].slice(), emulator.p[1].slice()],
		hires: emulator.hires,
	};
}

////////////////////////////////////
//
//   Audio Playback
//
////////////////////////////////////

var audio;
var audioNode;
var audioSource;
var audioData;

var AudioBuffer = function(buffer, duration) {
	if (!(this instanceof AudioBuffer)) {
		return new AudioBuffer(buffer, duration);
	}

	this.pointer = 0;
	this.buffer = buffer;
	this.duration = duration;
}

AudioBuffer.prototype.write = function(buffer, index, size) {
	size = Math.max(0, Math.min(size, this.duration))
	if (!size) { return size; }

	this.duration -= size;
	var bufferSize = this.buffer.length;
	var end = index + size;

	for(var i = index; i < end; ++i) {
		buffer[i] = this.buffer[this.pointer++];
		this.pointer %= bufferSize;
	}

	return size;
}

AudioBuffer.prototype.dequeue = function(duration) {
	this.duration -= duration;
}

var FREQ = 4000;
var TIMER_FREQ = 60;
var SAMPLES = 16;
var BUFFER_SIZE = SAMPLES * 8

function audioSetup() {
	if (!audio) {
		if (typeof AudioContext !== 'undefined') {
			audio = new AudioContext();
		}
		else if (typeof webkitAudioContext !== 'undefined') {
			audio = new webkitAudioContext();
		}
	}
	if (audio && !audioNode) {
		audioNode = audio.createScriptProcessor(4096, 1, 1);
		audioNode.onaudioprocess = function(audioProcessingEvent) {
			var outputBuffer = audioProcessingEvent.outputBuffer;
			var outputData = outputBuffer.getChannelData(0);
			var samples_n = outputBuffer.length;

			var index = 0;
			while(audioData.length && index < samples_n) {
				var size = samples_n - index;
				var written = audioData[0].write(outputData, index, size);
				index += written;
				if (written < size) {
					audioData.shift();
				}
			}

			while(index < samples_n) {
				outputData[index++] = 0;
			}
			//the last one can be long sound with high value of buzzer, so always keep it
			if (audioData.length > 1) {
				var audioDataSize = 0;
				var audioBufferSize = audioNode.bufferSize;
				audioData.forEach(function(buffer) { audioDataSize += buffer.duration; })
				while(audioDataSize > audioBufferSize && audioData.length > 1) {
					audioDataSize -= audioData.shift().duration;
				}
			}
		}
		audioData = [];
		audioNode.connect(audio.destination);
		return true;
	}
	if (audio && audioNode) { return true; }
	return false;
}

function stopAudio() {
	if (!audio) { return; }
	if (audioNode) {
		audioNode.disconnect();
		audioNode = null;
	}
	audioData = [];
}

var VOLUME = 0.25;

function playPattern(soundLength, buffer, remainingTicks) {
	if (!audio) { return; }

	var samples = Math.floor(BUFFER_SIZE * audio.sampleRate / FREQ);
	var audioBuffer = new Array(samples);
	if (remainingTicks && audioData.length > 0) {
		audioData[audioData.length - 1].dequeue(Math.floor(remainingTicks * audio.sampleRate / TIMER_FREQ));
	}

	for(var i = 0; i < samples; ++i) {
		var srcIndex = Math.floor(i * FREQ / audio.sampleRate);
		var cell = srcIndex >> 3;
		var bit = srcIndex & 7;
		audioBuffer[i] = (buffer[srcIndex >> 3] & (0x80 >> bit)) ? VOLUME: 0;
	}
	audioData.push(new AudioBuffer(audioBuffer, Math.floor(soundLength * audio.sampleRate / TIMER_FREQ)));
}

function escapeHtml(str) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
}
</script>
<script>/**
* Adaptive Input
**/

const ael = (element, event, listener) => element.addEventListener   (event, listener, { passive:false })
const rel = (element, event, listener) => element.removeEventListener(event, listener, { passive:false })
const pd  = event => (event.preventDefault(),event.stopPropagation())

const VIP_HEX  = '123c456d789ea0bf'.split('')
const VIP_KEYS = VIP_HEX.map(x => parseInt(x,16))

const GAMEPAD_STYLES = `
.gamepad{
  position:absolute;
  top:10%;
  left:0px;
  width:100%;
  height:90%;
  opacity:0.3;
  user-select: none;
  -webkit-user-select: none;
}
.gamepad .dpad{
  position:absolute;
  bottom: 50px;
  left:   50px;
  width:  250px;
  height: 250px;
  background: gray;
  border-radius: 50%;
  overflow:hidden;
}
.gamepad .stick{
  display:none;
  position:absolute;
  border-radius: 50%;
  width:100px;
  height:100px;
  margin-left:-50px;
  margin-top:-50px;
}
.gamepad .buttons{
  position:absolute;
  bottom: 50px;
  right:  50px;
  width:  250px;
  height: 250px;
}
.gamepad .gamebutton{
  position:absolute;
  width:  125px;
  height: 125px;
  background:gray;
  border-radius:50%;
  overflow:hidden;
  line-height: 125px;
  font-size:50px;
  font-weight:bold;
  color:darkgray;
  text-align:center;
}
.gamepad .dpad.active .stick {display:block;background:#444}
.gamepad .gamebutton.active{background:#444;}
.gamepad .gamebutton.b{left:0;bottom:0;}
.gamepad .gamebutton.a{right:0;top:0;}
`
const VIP_STYLES = `
.vip-pad {display:flex;flex-direction:column;align-items:center;z-index:2000;}
.vip-pad .keypad {display:flex;flex-direction:column;margin-top:10px;}
.vip-pad .keypad>div {display:flex;flex-direction:row;}
.vip-pad .keypad>div>div {
  -webkit-user-select: none;
  user-select: none;
  background:gray;
  width: 100px;
  height: 51px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 1px;
}
.vip-pad .keypad>div>div:active,
.vip-pad .keypad>div>div.active {background:black; border:1px solid white;margin:0px;}
`

const INPUT_MODULES = {
  /**
  * An invisible set of gesture recognizers,
  * giving directional input and an action for taps.
  **/
  swipe: {
    install: (screen,up,down,options) => {

      let vdirs      = []
      let direction  = { i:null, sx:0, sy:0, lx:0, ly:0 }
      let action1    = {}
      let taptimeout = null

      const updateStick = _ => {
        // find the relative position of the stick to its starting point
        const cx = direction.lx - direction.sx
        const cy = direction.ly - direction.sy

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }
      const tapDown= i => {
        if (Object.keys(action1).length == 0) down(options.action1)
        action1[i] = true
        if (i == direction.i) { direction = { i:null, sx:0, sy:0, lx:0, ly:0 } }
        taptimeout = null
      }
      const start = e => {
        const t = e.touches[0]
        const i = t.identifier
        // a single-touch is either directional or a tap...
        if (direction.i != null) {
          tapDown(i)
        }
        else {
          direction.i  = i
          direction.sx = t.clientX
          direction.sy = t.clientY
          direction.lx = t.clientX
          direction.ly = t.clientY
          taptimeout = setTimeout(_ => tapDown(i), 100)
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) { clearTimeout(taptimeout); taptimeout = null }
            direction.lx = t.clientX
            direction.ly = t.clientY
          }
        }
        updateStick(),pd(e)
      }
      const end = e => {
        let r1 = false
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) {
              // cancel a short tap
              clearTimeout(taptimeout); taptimeout = null
              down(options.action1)
              setTimeout(_ => up(options.action1), 50)
            }
            direction = { i:null, sx:0, sy:0, lx:0, ly:0 }
          }
          if (i in action1) {
            delete action1[i]
            r1=true
          }
        }
        if (r1 && Object.keys(action1).length == 0) up(options.action1)
        updateStick(),pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move)
      ael(screen, 'touchend',   end)
      screen.uninstallSwipe = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move)
        rel(screen, 'touchend',   end)
      }
    },
    remove: (screen) => {
      screen.uninstallSwipe()
      delete screen.uninstallSwipe
    }
  },

  /**
  * A virtual gamepad overlay with two remappable action keys.
  **/
  gamepad: {
    install: (screen,up,down,options) => {
      // build the UI
      if (document.querySelector('.gamepad')) return
      const root = document.createElement('div')
      root.classList.add('gamepad')
      root.innerHTML = `
      <div class='dpad'><div class='stick'></div></div>
      <div class='buttons'><div class='gamebutton b'>B</div><div class='gamebutton a'>A</div></div>
      <style>${GAMEPAD_STYLES}</style>`
      screen.parentElement.append(root)

      let vdirs      = []
      let directions = {}
      let buttons    = {}
      const pad   = document.querySelector('.gamepad .dpad')
      const stick = document.querySelector('.gamepad .dpad .stick')
      const a     = document.querySelector('.gamepad .gamebutton.a')
      const b     = document.querySelector('.gamepad .gamebutton.b')

      const updateStick = _ => {
        // find centroid of d-pad touchpoints ({0,0} if no touchpoints)
        const touches = Object.values(directions)
        let cx = 0, cy = 0, r = pad.getBoundingClientRect(), sr = stick.getBoundingClientRect()
        touches.forEach(t => (cx+=t.x, cy+=t.y))
        cx /= touches.length,         cy /= touches.length
        cx -= (r.left + (r.width/2)), cy -= (r.top + (r.height/2))

        // position the virtual stick, clamped within dpad
        const ca = Math.atan2(cy, cx)
        const cd = Math.min(Math.sqrt(cx*cx + cy*cy), (r.width/2)-(sr.width/2))
        stick.style.left = ((Math.cos(ca)*cd)+(r.width /2)|0)+'px'
        stick.style.top  = ((Math.sin(ca)*cd)+(r.height/2)|0)+'px'

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }

      const start = e => {
        for(let z = 0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          if (t.target == a) {
            t.target.classList.add('active')
            buttons[i]=options.action1
            down(options.action1)
          }
          if (t.target == b) {
            t.target.classList.add('active')
            buttons[i]=options.action2
            down(options.action2)
          }
          if (t.target == pad) {
            t.target.classList.add('active')
            directions[i]={x:t.clientX, y:t.clientY}
          }
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in directions) directions[i]={x:t.clientX, y:t.clientY}
        }
        updateStick(),pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in buttons) {
            t.target.classList.remove('active')
            up(buttons[i])
            delete buttons[i]
          }
          if (i in directions) {
            t.target.classList.remove('active')
            delete directions[i]
          }
        }
        updateStick(),pd(e)
      }

      ael(a,   'touchstart', start)
      ael(a,   'touchend',   end  )
      ael(b,   'touchstart', start)
      ael(b,   'touchend',   end  )
      ael(pad, 'touchstart', start)
      ael(pad, 'touchmove',  move )
      ael(pad, 'touchend',   end  )
    },
    remove: (screen) => {
      document.querySelector('.gamepad').remove()
    },
  },

  /**
  * Treat the entire screen, or a centered square region, as invisible buttons,
  * mapped out in the order of the VIP hex keypad.
  **/
  seg16: {
    install: (screen,up,down,options) => {
      const tmap = {}
      const pointToKey = touch => {
        // poll this for each point, as it may vary over time,
        // and experimentally it's never right initially...
        const r = screen.getBoundingClientRect()
        if (options.mode == 'center') {
          if (r.width > r.height) { r.x += (r.width - r.height)/2; r.width = r.height }
          else                    { r.y += (r.height - r.width)/2; r.height = r.width }
        }
        const x = touch.clientX - r.x
        const y = touch.clientY - r.y
        if (x < 0 || x > r.width || y < 0 || y > r.height) return null
        const tx = Math.floor(x / (r.width /4))
        const ty = Math.floor(y / (r.height/4))
        return VIP_KEYS[tx + (4 * ty)]
      }
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (k != null) down(k)
          tmap[i]=k
        }
        pd(e)
      }
      const move = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (tmap[i] == k) continue       // same cell, nothing to do.
          if (tmap[i] != null) up(tmap[i]) // release old key, if any
          if (k != null)       down(k)     // press new key, if any
          tmap[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z=0; z<e.changedTouches.length; z++) {
          const i = e.changedTouches[z].identifier
          const k = pointToKey(e.changedTouches[z])
          if (tmap[i] != null) up(tmap[i])
          tmap[i]=null
        }
        pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move )
      ael(screen, 'touchend',   end  )
      screen.uninstallSeg16 = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move )
        rel(screen, 'touchend',   end  )
      }
    },
    remove:  (screen) => {
      screen.uninstallSeg16()
      delete screen.uninstallSeg16
    },
  },

  /**
  * Provide a visible 4x4 representation of the VIP hex keypad.
  **/
  vip: {
    install: (screen,up,down,options) => {
      if (document.querySelector('.vip-pad')) return
      const root = document.createElement('div')
      root.classList.add('vip-pad')
      root.innerHTML = `<div class='keypad'>
        ${[0,1,2,3].map(r=>`<div>${[0,1,2,3].map(c=>`<div>${VIP_HEX[c+(r*4)].toUpperCase()}</div>`).join('')}</div>`).join('')}
      </div>
      <style>${VIP_STYLES}</style>`
      if (screen.parentElement == document.body) { screen.parentElement.append(root) }
      else { screen.parentElement.parentElement.append(root) }
      const buttons = []
      document.querySelectorAll('.vip-pad .keypad>div>div').forEach(x=>buttons.push(x)) // make an actual Array
      const held = {}
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          const k = VIP_KEYS[buttons.indexOf(t.target)]
          t.target.classList.add('active')
          down(k)
          held[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (held[i]) { up(held[i]); delete held[i] }
          t.target.classList.remove('active')
        }
        pd(e)
      }
      buttons.forEach(b => {
        ael(b, 'touchstart', start)
        ael(b, 'touchend',   end  )
      })
    },
    remove:  (screen) => {
      document.querySelector('.vip-pad').remove()
    },
  },
}

let adaptiveControlsInstalled = null

function injectAdaptiveControls(type, screen, keyup, keydown) {
  let options = {
    up:      5,
    down:    8,
    left:    7,
    right:   9,
    action1: 6,
    action2: 4,
    mode:    'center', // or 'fill', used by seg16
  }
  const lookup = vk => Object.keys(keymap[vk])[0]
  const install = _ => {
    rel(screen, 'touchstart', install)
    adaptiveControlsInstalled = type
    INPUT_MODULES[type].install(
      screen,
      key => keyup  ({ key:lookup(key), preventDefault:_=>_ }),
      key => keydown({ key:lookup(key), preventDefault:_=>_ }),
      options
    )
  }
  // uninstall anything that's already there:
  rel(screen, 'touchstart', install)
  if (adaptiveControlsInstalled) INPUT_MODULES[adaptiveControlsInstalled].remove(screen)

  if (type == 'none') return
  if (type == 'seg16fill') { type='seg16'; options.mode='fill' }
  // defer installing adaptive input until we actually see
  // an input event from the user:
  ael(screen, 'touchstart', install)
}
</script>
<body><canvas id='target' width=512 height=256></canvas></body>
<style>body{margin:0px;display:flex;flex-direction:column;align-items:center;justify-content:center;}</style>
<script>
const emulator = new Emulator()
unpackOptions(emulator, data.options)
setRenderTarget(4, 'target')
emulator.init({rom:data.rom})
emulator.importFlags = _ => getPref('octoFlagRegisters')
emulator.exportFlags = f => setPref('octoFlagRegisters',f)
emulator.buzzTrigger = (ticks,rest)=> playPattern(ticks, emulator.pattern, rest)
const kd = e=>{
	if (!audio) audioSetup()
	if (!(e.key in emulator.keys)) emulator.keys[e.key]=true
	e.preventDefault()
}
const ku = e=>{
	if (e.key in emulator.keys) delete emulator.keys[e.key]
	if (!emulator.waiting) return
	const kindex = keymapInverse[e.key]
	if (kindex != undefined) {
		emulator.waiting = false
		emulator.v[emulator.waitReg] = kindex
	}
	e.preventDefault()
}
window.addEventListener('keydown',kd,false)
window.addEventListener('keyup',ku,false)
intervalHandle = setInterval(_=>{
	if (emulator.halted) return
	for(var z = 0; (z<emulator.tickrate) && (!emulator.waiting); z++) emulator.tick()
	if (emulator.dt > 0) emulator.dt--
	if (emulator.st > 0) emulator.st--
	renderDisplay(emulator)
	document.body.style.backgroundColor = emulator.st?emulator.buzzColor:emulator.quietColor
}, 1000/60)

injectAdaptiveControls(emulator.touchInputMode,document.getElementById('target'),ku,kd)
</script>
